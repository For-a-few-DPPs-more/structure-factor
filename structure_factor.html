<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Structure factor &mdash; structure-factor  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/proof.css" type="text/css" />
      <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/proof.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tapers" href="tapers.html" />
    <link rel="prev" title="Spatial windows" href="spatial_windows.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            structure-factor
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="hyperuniformity.html">Hyperuniformity</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiscale_estimators.html">Multiscale estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="pair_correlation_function.html">Pair correlation function</a></li>
<li class="toctree-l1"><a class="reference internal" href="point_pattern.html">Point pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="point_processes.html">Point processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="spatial_windows.html">Spatial windows</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Structure factor</a></li>
<li class="toctree-l1"><a class="reference internal" href="tapers.html">Tapers</a></li>
<li class="toctree-l1"><a class="reference internal" href="tapered_estimators.html">Tapered estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="tapered_estimators_isotropic.html">Tapered isotropic estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="transforms.html">Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography/index.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">structure-factor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Structure factor</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/For-a-few-DPPs-more/structure-factor/blob/main/docs/structure_factor.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-structure_factor.structure_factor">
<span id="id1"></span><span id="structure-factor"></span><h1>Structure factor<a class="headerlink" href="#module-structure_factor.structure_factor" title="Permalink to this headline"></a></h1>
<p>Class collecting estimators of the structure factor <span class="math notranslate nohighlight">\(S(\mathbf{k})\)</span> of stationary point process given one realization encapsulated in a <a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern" title="structure_factor.point_pattern.PointPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPattern</span></code></a>.</p>
<p><strong>The available estimators:</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.scattering_intensity" title="structure_factor.structure_factor.StructureFactor.scattering_intensity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scattering_intensity()</span></code></a>: The scattering intensity and the corresponding debiased versions.</p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.tapered_estimator" title="structure_factor.structure_factor.StructureFactor.tapered_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator()</span></code></a>: The tapered or multitapered estimator and the corresponding debiased versions.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator_isotropic()</span></code>: Bartlett’s isotropic estimator.</p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic" title="structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quadrature_estimator_isotropic()</span></code></a>: Integral estimation using Hankel transform quadrature.</p></li>
</ul>
<p><strong>The available plot methods:</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator" title="structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_non_isotropic_estimator()</span></code></a>: Visualize the results of <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.scattering_intensity" title="structure_factor.structure_factor.StructureFactor.scattering_intensity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scattering_intensity()</span></code></a>, <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.tapered_estimator" title="structure_factor.structure_factor.StructureFactor.tapered_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator()</span></code></a>, or <code class="xref py py-meth docutils literal notranslate"><span class="pre">multitapered_estimator()</span></code>.</p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.plot_isotropic_estimator" title="structure_factor.structure_factor.StructureFactor.plot_isotropic_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_isotropic_estimator()</span></code></a>: Visualize the results of <code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator_isotropic()</span></code> or <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic" title="structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quadrature_estimator_isotropic()</span></code></a>.</p></li>
</ul>
<p>For the theoretical derivation and definitions of these estimators, we refer to <span id="id2">[<a class="reference internal" href="bibliography/index.html#id4" title="Diala Hawat, Guillaume Gautier, Rémi Bardenet, and Raphaël Lachièze-Rey. On estimating the structure factor of a point process, with applications to hyperuniformity. arXiv preprint, 2022. arXiv: 2203.08749.">HGBLachiezeR22</a>]</span>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">structure_factor.structure_factor.</span></span><span class="sig-name descname"><span class="pre">StructureFactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_pattern</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implementation of various estimators of the structure factor <span class="math notranslate nohighlight">\(S(\mathbf{k})\)</span> of a stationary point process given one realization encapsulated in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">point_pattern</span></code> attribute.</p>
<div class="proof proof-type-definition" id="id14">

    <div class="proof-title">
        <span class="proof-type">Definition </span>
        
    </div><div class="proof-content">
<p>The structure factor <span class="math notranslate nohighlight">\(S\)</span> of a d-dimensional stationary point process <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> with intensity <span class="math notranslate nohighlight">\(\rho\)</span> is defined by,</p>
<div class="math notranslate nohighlight">
\[S(\mathbf{k}) = 1 + \rho \mathcal{F}(g-1)(\mathbf{k}),\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> denotes the Fourier transform, <span class="math notranslate nohighlight">\(g\)</span> the pair correlation function of <span class="math notranslate nohighlight">\(\mathcal{X}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> a wavevector of <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>.
For more details we refer to <span id="id4">[<a class="reference internal" href="bibliography/index.html#id4" title="Diala Hawat, Guillaume Gautier, Rémi Bardenet, and Raphaël Lachièze-Rey. On estimating the structure factor of a point process, with applications to hyperuniformity. arXiv preprint, 2022. arXiv: 2203.08749.">HGBLachiezeR22</a>]</span>, (Section 2) or <span id="id5">[<a class="reference internal" href="bibliography/index.html#id11" title="S. Torquato. Hyperuniform states of matter. Physics Reports, 2018. doi:10.1016/j.physrep.2018.03.001.">Tor18</a>]</span>, (Section 2.1, equation (13)).</p>
</div></div><dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_pattern</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize StructureFactor from <code class="docutils literal notranslate"><span class="pre">point_pattern</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point_pattern</strong> (<a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern" title="structure_factor.point_pattern.PointPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointPattern</span></code></a>) – Object of type point pattern which contains a realization <code class="docutils literal notranslate"><span class="pre">point_pattern.points</span></code> of a point process, the window where the points were simulated <code class="docutils literal notranslate"><span class="pre">point_pattern.window</span></code> and (optionally) the intensity of the point process <code class="docutils literal notranslate"><span class="pre">point_pattern.intensity</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.dimension">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimension</span></span><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.dimension" title="Permalink to this definition"></a></dt>
<dd><p>Ambient dimension of the underlying point process.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.scattering_intensity">
<span class="sig-name descname"><span class="pre">scattering_intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debiased</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.scattering_intensity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.scattering_intensity" title="Permalink to this definition"></a></dt>
<dd><p>Compute the scattering intensity <span class="math notranslate nohighlight">\(\widehat{S}_{\mathrm{SI}}\)</span> estimate of the structure factor from one realization of a stationary point process encapsulated in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">point_pattern</span></code> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>numpy.ndarray</em><em>, </em><em>optional</em>) – Array of size <span class="math notranslate nohighlight">\(n \times d\)</span>  where <span class="math notranslate nohighlight">\(d\)</span> is the dimension of the space, and <span class="math notranslate nohighlight">\(n\)</span> is the number of wavevectors where the scattering intensity is evaluated. If <code class="docutils literal notranslate"><span class="pre">k=None</span></code> and <code class="docutils literal notranslate"><span class="pre">debiased=True</span></code>, the scattering intensity will be evaluated on the corresponding set of allowed wavevectors; In this case, the keyword arguments <code class="docutils literal notranslate"><span class="pre">k_max</span></code>, and <code class="docutils literal notranslate"><span class="pre">meshgrid_shape</span></code> can be used. Defaults to None.</p></li>
<li><p><strong>debiased</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>Trigger the use of a debiased tapered estimator. Defaults to True. If <code class="docutils literal notranslate"><span class="pre">debiased=True</span></code>, the estimator is debiased as follows,</p>
<ul>
<li><p>if <code class="docutils literal notranslate"><span class="pre">k=None</span></code>, the scattering intensity will be evaluated on the corresponding set of allowed wavevectors.</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">k</span></code> is not None and <code class="docutils literal notranslate"><span class="pre">direct=True</span></code>, the direct debiased scattering intensity will be used,</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">k</span></code> is not None and <code class="docutils literal notranslate"><span class="pre">direct=False</span></code>, the undirect debiased scattering intensity will be used.</p></li>
</ul>
</p></li>
<li><p><strong>direct</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">debiased</span></code> is True, trigger the use of the direct/undirect debiased scattering intensity. Parameter related to <code class="docutils literal notranslate"><span class="pre">debiased</span></code>. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>params</strong> (<em>dict</em>) – Keyword arguments <code class="docutils literal notranslate"><span class="pre">k_max</span></code> and <code class="docutils literal notranslate"><span class="pre">meshgrid_shape</span></code> of <a class="reference internal" href="tapered_estimators.html#structure_factor.tapered_estimators.allowed_k_scattering_intensity" title="structure_factor.tapered_estimators.allowed_k_scattering_intensity"><code class="xref py py-func docutils literal notranslate"><span class="pre">allowed_k_scattering_intensity()</span></code></a>, used when <code class="docutils literal notranslate"><span class="pre">k=None</span></code> and <code class="docutils literal notranslate"><span class="pre">debiased=True</span></code>.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>k: Wavevector(s) on which the scattering intensity has been evaluated.</p></li>
<li><p>estimation: Evaluation of the scattering intensity estimator of the structure factor at <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple(numpy.ndarray, numpy.ndarray)</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">structure_factor.point_processes</span> <span class="kn">import</span> <span class="n">HomogeneousPoissonPointProcess</span>
<span class="kn">from</span> <span class="nn">structure_factor.spatial_windows</span> <span class="kn">import</span> <span class="n">BoxWindow</span>
<span class="kn">from</span> <span class="nn">structure_factor.structure_factor</span> <span class="kn">import</span> <span class="n">StructureFactor</span>

<span class="n">point_process</span> <span class="o">=</span> <span class="n">HomogeneousPoissonPointProcess</span><span class="p">(</span><span class="n">intensity</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="n">window</span> <span class="o">=</span> <span class="n">BoxWindow</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
<span class="n">point_pattern</span> <span class="o">=</span> <span class="n">point_process</span><span class="o">.</span><span class="n">generate_point_pattern</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

<span class="n">sf</span> <span class="o">=</span> <span class="n">StructureFactor</span><span class="p">(</span><span class="n">point_pattern</span><span class="p">)</span>
<span class="n">k</span><span class="p">,</span> <span class="n">sf_estimated</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">scattering_intensity</span><span class="p">(</span><span class="n">k_max</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="n">sf</span><span class="o">.</span><span class="n">plot_non_isotropic_estimator</span><span class="p">(</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">sf_estimated</span><span class="p">,</span>
    <span class="n">plot_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">error_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">exact_sf</span><span class="o">=</span><span class="n">point_process</span><span class="o">.</span><span class="n">structure_factor</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\widehat</span><span class="si">{S}</span><span class="s2">_{\mathrm</span><span class="si">{SI}</span><span class="s2">}(\mathbf</span><span class="si">{k}</span><span class="s2">)$&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./code/structure_factor/scattering_intensity.py">Source code</a>, <a class="reference external" href="./code/structure_factor/scattering_intensity.png">png</a>, <a class="reference external" href="./code/structure_factor/scattering_intensity.hires.png">hires.png</a>, <a class="reference external" href="./code/structure_factor/scattering_intensity.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="_images/scattering_intensity.png" class="plot-directive" src="_images/scattering_intensity.png" />
</figure>
<div class="proof proof-type-definition" id="id15">

    <div class="proof-title">
        <span class="proof-type">Definition </span>
        
    </div><div class="proof-content">
<p>The scattering intensity <span class="math notranslate nohighlight">\(\widehat{S}_{\mathrm{SI}}\)</span> is an estimator of the structure factor <span class="math notranslate nohighlight">\(S\)</span> of a stationary point process <span class="math notranslate nohighlight">\(\mathcal{X} \subset \mathbb{R}^d\)</span> with intensity <span class="math notranslate nohighlight">\(\rho\)</span>. It is computed from one realization <span class="math notranslate nohighlight">\(\mathcal{X}\cap W =\{\mathbf{x}_i\}_{i=1}^N\)</span> of <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> within a box window <span class="math notranslate nohighlight">\(W=\prod_{j=1}^d[-L_j/2, L_j/2]\)</span>.</p>
<div class="math notranslate nohighlight">
\[\widehat{S}_{\mathrm{SI}}(\mathbf{k}) =
 \frac{1}{N}\left\lvert
     \sum_{j=1}^N
         \exp(- i \left\langle \mathbf{k}, \mathbf{x_j} \right\rangle)
 \right\rvert^2 .\]</div>
<p>For more details we refer to <span id="id6">[<a class="reference internal" href="bibliography/index.html#id4" title="Diala Hawat, Guillaume Gautier, Rémi Bardenet, and Raphaël Lachièze-Rey. On estimating the structure factor of a point process, with applications to hyperuniformity. arXiv preprint, 2022. arXiv: 2203.08749.">HGBLachiezeR22</a>]</span>, (Section 3.1).</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Typical usage</strong></p>
<ul class="simple">
<li><p>If the observation window is not a <a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BoxWindow" title="structure_factor.spatial_windows.BoxWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxWindow</span></code></a>, use the method <a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern.restrict_to_window" title="structure_factor.point_pattern.PointPattern.restrict_to_window"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restrict_to_window()</span></code></a> to extract a sub-sample in a <a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BoxWindow" title="structure_factor.spatial_windows.BoxWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxWindow</span></code></a>.</p></li>
</ul>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="tapered_estimators.html#structure_factor.tapered_estimators.scattering_intensity" title="structure_factor.tapered_estimators.scattering_intensity"><code class="xref py py-func docutils literal notranslate"><span class="pre">scattering_intensity()</span></code></a></p></li>
<li><p><a class="reference internal" href="tapered_estimators.html#structure_factor.tapered_estimators.allowed_k_scattering_intensity" title="structure_factor.tapered_estimators.allowed_k_scattering_intensity"><code class="xref py py-func docutils literal notranslate"><span class="pre">allowed_k_scattering_intensity()</span></code></a></p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.tapered_estimator" title="structure_factor.structure_factor.StructureFactor.tapered_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator" title="structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_non_isotropic_estimator()</span></code></a></p></li>
<li><p><a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BoxWindow" title="structure_factor.spatial_windows.BoxWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxWindow</span></code></a></p></li>
<li><p><a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern.restrict_to_window" title="structure_factor.point_pattern.PointPattern.restrict_to_window"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restrict_to_window()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.tapered_estimator">
<span class="sig-name descname"><span class="pre">tapered_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tapers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debiased</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.tapered_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.tapered_estimator" title="Permalink to this definition"></a></dt>
<dd><p>Compute the (multi)tapered estimator parametrized by <code class="docutils literal notranslate"><span class="pre">tapers</span></code> of the structure factor of a stationary point process given a realization encapsulated in <code class="docutils literal notranslate"><span class="pre">point_pattern</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>numpy.ndarray</em>) – Array of size <span class="math notranslate nohighlight">\(n \times d\)</span>  where <span class="math notranslate nohighlight">\(d\)</span> is the dimension of the space, and <span class="math notranslate nohighlight">\(n\)</span> is the number of wavevectors where the tapered estimator is evaluated.</p></li>
<li><p><strong>t1</strong> – sequence of concrete tapers with methods <code class="docutils literal notranslate"><span class="pre">.taper(x,</span> <span class="pre">window)</span></code> corresponding to the taper function <span class="math notranslate nohighlight">\(t(x, W)\)</span> , and <code class="docutils literal notranslate"><span class="pre">.ft_taper(k,</span> <span class="pre">window)</span></code> corresponding to the Fourier transform <span class="math notranslate nohighlight">\(\mathcal{F}[t(\cdot, W)](k)\)</span> of the taper. See also <a class="reference internal" href="tapers.html#tapers"><span class="std std-ref">Tapers</span></a>.</p></li>
<li><p><strong>t2</strong> – sequence of concrete tapers with methods <code class="docutils literal notranslate"><span class="pre">.taper(x,</span> <span class="pre">window)</span></code> corresponding to the taper function <span class="math notranslate nohighlight">\(t(x, W)\)</span> , and <code class="docutils literal notranslate"><span class="pre">.ft_taper(k,</span> <span class="pre">window)</span></code> corresponding to the Fourier transform <span class="math notranslate nohighlight">\(\mathcal{F}[t(\cdot, W)](k)\)</span> of the taper. See also <a class="reference internal" href="tapers.html#tapers"><span class="std std-ref">Tapers</span></a>.</p></li>
<li><p><strong>...</strong> – sequence of concrete tapers with methods <code class="docutils literal notranslate"><span class="pre">.taper(x,</span> <span class="pre">window)</span></code> corresponding to the taper function <span class="math notranslate nohighlight">\(t(x, W)\)</span> , and <code class="docutils literal notranslate"><span class="pre">.ft_taper(k,</span> <span class="pre">window)</span></code> corresponding to the Fourier transform <span class="math notranslate nohighlight">\(\mathcal{F}[t(\cdot, W)](k)\)</span> of the taper. See also <a class="reference internal" href="tapers.html#tapers"><span class="std std-ref">Tapers</span></a>.</p></li>
<li><p><strong>debiased</strong> (<em>bool</em><em>, </em><em>optional</em>) – Trigger the use of a debiased estimator. Defaults to True.</p></li>
<li><p><strong>direct</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">debiased</span></code> is True, trigger the use of the direct/undirect debiased tapered estimator. Parameter related to <code class="docutils literal notranslate"><span class="pre">debiased</span></code>. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>k: Wavevector(s) on which the tapered estimator has been evaluated.</p></li>
<li><p>estimation: Evaluation of the tapered estimator at <code class="docutils literal notranslate"><span class="pre">k</span></code>..</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple(numpy.ndarray, numpy.ndarray)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this method with its default arguments is equivalent to calling <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.scattering_intensity" title="structure_factor.structure_factor.StructureFactor.scattering_intensity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scattering_intensity()</span></code></a>.</p>
</div>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">structure_factor.point_processes</span> <span class="kn">import</span> <span class="n">HomogeneousPoissonPointProcess</span>
<span class="kn">from</span> <span class="nn">structure_factor.spatial_windows</span> <span class="kn">import</span> <span class="n">BoxWindow</span>
<span class="kn">from</span> <span class="nn">structure_factor.structure_factor</span> <span class="kn">import</span> <span class="n">StructureFactor</span>
<span class="kn">from</span> <span class="nn">structure_factor.tapers</span> <span class="kn">import</span> <span class="n">multi_sinetaper_grid</span>
<span class="kn">from</span> <span class="nn">structure_factor.utils</span> <span class="kn">import</span> <span class="n">meshgrid_to_column_matrix</span>

<span class="n">point_process</span> <span class="o">=</span> <span class="n">HomogeneousPoissonPointProcess</span><span class="p">(</span><span class="n">intensity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">BoxWindow</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
<span class="n">point_pattern</span> <span class="o">=</span> <span class="n">point_process</span><span class="o">.</span><span class="n">generate_point_pattern</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

<span class="n">sf</span> <span class="o">=</span> <span class="n">StructureFactor</span><span class="p">(</span><span class="n">point_pattern</span><span class="p">)</span>

<span class="c1"># Use the family of sine tapers</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">meshgrid_to_column_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>


<span class="n">tapers</span> <span class="o">=</span> <span class="n">multi_sinetaper_grid</span><span class="p">(</span><span class="n">point_pattern</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">p_component_max</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">k</span><span class="p">,</span> <span class="n">sf_estimated</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">tapered_estimator</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">tapers</span><span class="o">=</span><span class="n">tapers</span><span class="p">,</span> <span class="n">debiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">sf</span><span class="o">.</span><span class="n">plot_non_isotropic_estimator</span><span class="p">(</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">sf_estimated</span><span class="p">,</span>
    <span class="n">plot_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">error_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\widehat</span><span class="si">{S}</span><span class="s2">_{\mathrm</span><span class="si">{MDDTP}</span><span class="s2">}((t_j)_1^4, \mathbf</span><span class="si">{k}</span><span class="s2">)$&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./code/structure_factor/multitapered_estimator.py">Source code</a>, <a class="reference external" href="./code/structure_factor/multitapered_estimator.png">png</a>, <a class="reference external" href="./code/structure_factor/multitapered_estimator.hires.png">hires.png</a>, <a class="reference external" href="./code/structure_factor/multitapered_estimator.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="_images/multitapered_estimator.png" class="plot-directive" src="_images/multitapered_estimator.png" />
</figure>
<div class="proof proof-type-definition" id="id16">

    <div class="proof-title">
        <span class="proof-type">Definition </span>
        
    </div><div class="proof-content">
<p>The tapered estimator <span class="math notranslate nohighlight">\(\widehat{S}_{\mathrm{TP}}(t, k)\)</span>, is an estimator of the structure factor <span class="math notranslate nohighlight">\(S\)</span> of a stationary point process <span class="math notranslate nohighlight">\(\mathcal{X} \subset \mathbb{R}^d\)</span> with intensity <span class="math notranslate nohighlight">\(\rho\)</span>. It is computed from one realization <span class="math notranslate nohighlight">\(\mathcal{X}\cap W =\{\mathbf{x}_i\}_{i=1}^N\)</span> of <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> within a box window <span class="math notranslate nohighlight">\(W\)</span>.</p>
<div class="math notranslate nohighlight">
\[\widehat{S}_{\mathrm{TP}}(t, \mathbf{k}) = \frac{1}{\rho} \left\lvert \sum_{j=1}^N t(x_j, W) \exp(- i \left\langle k, x_j \right\rangle)\right\rvert^2,\]</div>
<p>If several tapers are used, a simple average of the corresponding tapered estimators is computed. The resulting estimator is call multitapered estimator.</p>
<div class="math notranslate nohighlight">
\[\widehat{S}_{\mathrm{MTP}}((t_{q})_{q=1}^P, \mathbf{k}) = \frac{1}{P}\sum_{q=1}^{P} \widehat{S}(t_{q}, \mathbf{k})\]</div>
<p>where, <span class="math notranslate nohighlight">\((t_{q})_{q}\)</span> is a family of tapers supported on the observation window (satisfying some conditions), <span class="math notranslate nohighlight">\(P\)</span> is the number of tapers used, and <span class="math notranslate nohighlight">\(k \in \mathbb{R}^d\)</span>.
For more details, we refer to <span id="id7">[<a class="reference internal" href="bibliography/index.html#id4" title="Diala Hawat, Guillaume Gautier, Rémi Bardenet, and Raphaël Lachièze-Rey. On estimating the structure factor of a point process, with applications to hyperuniformity. arXiv preprint, 2022. arXiv: 2203.08749.">HGBLachiezeR22</a>]</span>, (Section 3.1).</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Typical usage</strong></p>
<ul class="simple">
<li><p>If the observation window is not a <a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BoxWindow" title="structure_factor.spatial_windows.BoxWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxWindow</span></code></a>, use the method <a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern.restrict_to_window" title="structure_factor.point_pattern.PointPattern.restrict_to_window"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restrict_to_window()</span></code></a> to extract a sub-sample in a <a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BoxWindow" title="structure_factor.spatial_windows.BoxWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxWindow</span></code></a>.</p></li>
</ul>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.scattering_intensity" title="structure_factor.structure_factor.StructureFactor.scattering_intensity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scattering_intensity()</span></code></a></p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator" title="structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_non_isotropic_estimator()</span></code></a></p></li>
<li><p><a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BoxWindow" title="structure_factor.spatial_windows.BoxWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxWindow</span></code></a></p></li>
<li><p><a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern.restrict_to_window" title="structure_factor.point_pattern.PointPattern.restrict_to_window"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restrict_to_window()</span></code></a></p></li>
<li><p><a class="reference internal" href="tapers.html#tapers"><span class="std std-ref">Tapers</span></a></p></li>
<li><p><a class="reference internal" href="tapers.html#structure_factor.tapers.SineTaper" title="structure_factor.tapers.SineTaper"><code class="xref py py-class docutils literal notranslate"><span class="pre">SineTaper</span></code></a></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">multitapered_estimator()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.bartlett_isotropic_estimator">
<span class="sig-name descname"><span class="pre">bartlett_isotropic_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.bartlett_isotropic_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.bartlett_isotropic_estimator" title="Permalink to this definition"></a></dt>
<dd><p>Compute Bartlett’s isotropic estimator <span class="math notranslate nohighlight">\(\widehat{S}_{\mathrm{BI}}\)</span> from one realization of an isotropic point process encapsulated in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">point_pattern</span></code> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k_norm</strong> (<em>numpy.ndarray</em><em>, </em><em>optional</em>) – Array of wavenumbers of size <span class="math notranslate nohighlight">\(n\)</span> where the estimator is to be evaluated. Defaults to None.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>params</strong> (<em>dict</em>) – Keyword argument <code class="docutils literal notranslate"><span class="pre">nb_values</span></code> of <code class="xref py py-func docutils literal notranslate"><span class="pre">allowed_k_norm_bartlett_isotropic</span> <span class="pre">used</span> <span class="pre">when</span> <span class="pre">``k_norm=None`()</span></code> to specify the number of allowed wavenumbers to be considered.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>k_norm: Wavenumber(s) on which Bartlett’s isotropic estimator has been evaluated.</p></li>
<li><p>estimation: Evaluation(s) of Bartlett’s isotropic estimator at <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple(numpy.ndarray, numpy.ndarray)</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">structure_factor.point_processes</span> <span class="kn">import</span> <span class="n">HomogeneousPoissonPointProcess</span>
<span class="kn">from</span> <span class="nn">structure_factor.spatial_windows</span> <span class="kn">import</span> <span class="n">BallWindow</span>
<span class="kn">from</span> <span class="nn">structure_factor.structure_factor</span> <span class="kn">import</span> <span class="n">StructureFactor</span>
<span class="kn">from</span> <span class="nn">structure_factor.tapered_estimators_isotropic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">allowed_k_norm_bartlett_isotropic</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">point_process</span> <span class="o">=</span> <span class="n">HomogeneousPoissonPointProcess</span><span class="p">(</span><span class="n">intensity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">BallWindow</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">point_pattern</span> <span class="o">=</span> <span class="n">point_process</span><span class="o">.</span><span class="n">generate_point_pattern</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

<span class="n">sf</span> <span class="o">=</span> <span class="n">StructureFactor</span><span class="p">(</span><span class="n">point_pattern</span><span class="p">)</span>
<span class="n">d</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">point_pattern</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">point_pattern</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">radius</span>
<span class="n">k_norm</span> <span class="o">=</span> <span class="n">allowed_k_norm_bartlett_isotropic</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">nb_values</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">k_norm</span><span class="p">,</span> <span class="n">sf_estimated</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">bartlett_isotropic_estimator</span><span class="p">(</span><span class="n">k_norm</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">plot_isotropic_estimator</span><span class="p">(</span>
    <span class="n">k_norm</span><span class="p">,</span> <span class="n">sf_estimated</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\widehat</span><span class="si">{S}</span><span class="s2">_{\mathrm</span><span class="si">{BI}</span><span class="s2">}(k)$&quot;</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./code/structure_factor/bartlett_isotropic_estimator.py">Source code</a>, <a class="reference external" href="./code/structure_factor/bartlett_isotropic_estimator.png">png</a>, <a class="reference external" href="./code/structure_factor/bartlett_isotropic_estimator.hires.png">hires.png</a>, <a class="reference external" href="./code/structure_factor/bartlett_isotropic_estimator.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="_images/bartlett_isotropic_estimator.png" class="plot-directive" src="_images/bartlett_isotropic_estimator.png" />
</figure>
<div class="proof proof-type-definition" id="id17">

    <div class="proof-title">
        <span class="proof-type">Definition </span>
        
    </div><div class="proof-content">
<p>Bartlett’s isotropic estimator <span class="math notranslate nohighlight">\(\widehat{S}_{\mathrm{BI}}\)</span> is an estimator of the structure factor <span class="math notranslate nohighlight">\(S\)</span> of a stationary isotropic point process <span class="math notranslate nohighlight">\(\mathcal{X} \subset \mathbb{R}^d\)</span> with intensity <span class="math notranslate nohighlight">\(\rho\)</span>. It is computed from one realization <span class="math notranslate nohighlight">\(\mathcal{X}\cap W =\{\mathbf{x}_i\}_{i=1}^N\)</span> of <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> within a ball window <span class="math notranslate nohighlight">\(W=B(\mathbf{0}, R)\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\widehat{S}_{\mathrm{BI}}(k)
= 1 + \frac{ (2\pi)^{d/2} }{\rho |W| \omega_{d-1}} \sum_{ \substack{j, q =1 \\ j\neq q } }^{N }
 \frac{1}{(k \|\mathbf{x}_j - \mathbf{x}_q\|_2)^{d/2 - 1}}
J_{d/2 - 1}(k \|\mathbf{x}_j - \mathbf{x}_q\|_2).\end{split}\]</div>
<p>For more details, we refer to <span id="id8">[<a class="reference internal" href="bibliography/index.html#id4" title="Diala Hawat, Guillaume Gautier, Rémi Bardenet, and Raphaël Lachièze-Rey. On estimating the structure factor of a point process, with applications to hyperuniformity. arXiv preprint, 2022. arXiv: 2203.08749.">HGBLachiezeR22</a>]</span>, (Section 3.2).</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Typical usage</strong></p>
<ul class="simple">
<li><p>If the observation window is not a <a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BallWindow" title="structure_factor.spatial_windows.BallWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallWindow</span></code></a>, use the method <a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern.restrict_to_window" title="structure_factor.point_pattern.PointPattern.restrict_to_window"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restrict_to_window()</span></code></a> to extract a sub-sample in a <a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BallWindow" title="structure_factor.spatial_windows.BallWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallWindow</span></code></a>.</p></li>
</ul>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.BallWindow" title="structure_factor.spatial_windows.BallWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallWindow</span></code></a></p></li>
<li><p><a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern.restrict_to_window" title="structure_factor.point_pattern.PointPattern.restrict_to_window"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restrict_to_window()</span></code></a></p></li>
<li><p><a class="reference internal" href="tapered_estimators_isotropic.html#module-structure_factor.tapered_estimators_isotropic" title="structure_factor.tapered_estimators_isotropic"><code class="xref py py-func docutils literal notranslate"><span class="pre">tapered_estimators_isotropic()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic">
<span class="sig-name descname"><span class="pre">quadrature_estimator_isotropic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pcf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BaddourChouinard'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.quadrature_estimator_isotropic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic" title="Permalink to this definition"></a></dt>
<dd><p>Approximate the structure factor of a stationary isotropic point process at values <code class="docutils literal notranslate"><span class="pre">k_norm</span></code>, given its pair correlation function <code class="docutils literal notranslate"><span class="pre">pcf</span></code>, using a quadrature <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It only applies to point processes in even dimension <span class="math notranslate nohighlight">\(d\)</span>, due to evaluations of the zeros of Bessel functions of order <span class="math notranslate nohighlight">\(d / 2 - 1\)</span> that must integer-valued.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pcf</strong> (<em>callable</em>) – Pair correlation function.</p></li>
<li><p><strong>k_norm</strong> (<em>numpy.ndarray</em><em>, </em><em>optional</em>) – Vector of wavenumbers (i.e., norms of wavevectors) where the structure factor is to be evaluated. Optional if <code class="docutils literal notranslate"><span class="pre">method=&quot;BaddourChouinard&quot;</span></code> (since this method evaluates the Hankel transform on a specific set of wavenumbers), but it is <strong>non optional</strong> if <code class="docutils literal notranslate"><span class="pre">method=&quot;Ogata&quot;</span></code>. Defaults to None.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Trigger the use of <code class="docutils literal notranslate"><span class="pre">&quot;BaddourChouinard&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;Ogata&quot;</span></code> quadrature to estimate the structure factor. Defaults to <code class="docutils literal notranslate"><span class="pre">&quot;BaddourChouinard&quot;</span></code>,</p>
<ul>
<li><p>if <code class="docutils literal notranslate"><span class="pre">&quot;BaddourChouinard&quot;</span></code>: The Hankel transform is approximated using the Discrete Hankel transform <span id="id9">[<a class="reference internal" href="bibliography/index.html#id2" title="Natalie Baddour and Ugo Chouinard. Theory and operational rules for the discrete hankel transform. J. Opt. Soc. Am. A, 32(4):611–622, Apr 2015. doi:10.1364/JOSAA.32.000611.">BC15</a>]</span>. See <a class="reference internal" href="transforms.html#structure_factor.transforms.HankelTransformBaddourChouinard" title="structure_factor.transforms.HankelTransformBaddourChouinard"><code class="xref py py-class docutils literal notranslate"><span class="pre">HankelTransformBaddourChouinard</span></code></a></p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">&quot;Ogata&quot;</span></code>: The Hankel transform is approximated using Ogata quadrature <span id="id10">[<a class="reference internal" href="bibliography/index.html#id7" title="H. Ogata. A numerical integration formula based on the bessel functions. Research Institute for Mathematical Sciences, 2005. doi:10.2977/prims/1145474602.">Oga05</a>]</span>. See <a class="reference internal" href="transforms.html#structure_factor.transforms.HankelTransformOgata" title="structure_factor.transforms.HankelTransformOgata"><code class="xref py py-class docutils literal notranslate"><span class="pre">HankelTransformOgata</span></code></a></p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>params</strong> (<em>dict</em>) – <p>Keyword arguments passed to the corresponding Hankel transformer selected according to the input argument <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">==</span> <span class="pre">&quot;Ogata&quot;</span></code>, see <a class="reference internal" href="transforms.html#structure_factor.transforms.HankelTransformOgata.compute_transformation_parameters" title="structure_factor.transforms.HankelTransformOgata.compute_transformation_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_transformation_parameters()</span></code></a></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">step_size</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nb_points</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">==</span> <span class="pre">&quot;BaddourChouinard&quot;</span></code>, see <a class="reference internal" href="transforms.html#structure_factor.transforms.HankelTransformBaddourChouinard.compute_transformation_parameters" title="structure_factor.transforms.HankelTransformBaddourChouinard.compute_transformation_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_transformation_parameters()</span></code></a></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r_max</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nb_points</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolotation</span></code> dictionnary containing the keyword arguments of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html">scipy.integrate.interp1d</a> parameters.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>k_norm: Vector of wavenumbers.</p></li>
<li><p>estimation: Evaluations of the structure factor on <code class="docutils literal notranslate"><span class="pre">k_norm</span></code>.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple (numpy.ndarray, numpy.ndarray)</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">structure_factor.pair_correlation_function</span> <span class="k">as</span> <span class="nn">pcf</span>
<span class="kn">from</span> <span class="nn">structure_factor.point_processes</span> <span class="kn">import</span> <span class="n">HomogeneousPoissonPointProcess</span>
<span class="kn">from</span> <span class="nn">structure_factor.spatial_windows</span> <span class="kn">import</span> <span class="n">BallWindow</span>
<span class="kn">from</span> <span class="nn">structure_factor.structure_factor</span> <span class="kn">import</span> <span class="n">StructureFactor</span>

<span class="n">point_process</span> <span class="o">=</span> <span class="n">HomogeneousPoissonPointProcess</span><span class="p">(</span><span class="n">intensity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">window</span> <span class="o">=</span> <span class="n">BallWindow</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">point_pattern</span> <span class="o">=</span> <span class="n">point_process</span><span class="o">.</span><span class="n">generate_point_pattern</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

<span class="n">pcf_estimated</span> <span class="o">=</span> <span class="n">pcf</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
    <span class="n">point_pattern</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fv&quot;</span><span class="p">,</span> <span class="n">Kest</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">rmax</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="n">fv</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">spar</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Interpolate/extrapolate the results</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">pcf_estimated</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span>
<span class="n">pcf_r</span> <span class="o">=</span> <span class="n">pcf_estimated</span><span class="p">[</span><span class="s2">&quot;pcf&quot;</span><span class="p">]</span>
<span class="n">pcf_interpolated</span> <span class="o">=</span> <span class="n">pcf</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">pcf_r</span><span class="o">=</span><span class="n">pcf_r</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Estimate the structure factor using Baddour Chouinard quadrature</span>
<span class="n">sf</span> <span class="o">=</span> <span class="n">StructureFactor</span><span class="p">(</span><span class="n">point_pattern</span><span class="p">)</span>
<span class="n">k_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>  <span class="c1"># vector of wavelength</span>
<span class="n">k_norm</span><span class="p">,</span> <span class="n">sf_estimated</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">quadrature_estimator_isotropic</span><span class="p">(</span>
    <span class="n">pcf_interpolated</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;BaddourChouinard&quot;</span><span class="p">,</span> <span class="n">k_norm</span><span class="o">=</span><span class="n">k_norm</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">nb_points</span><span class="o">=</span><span class="mi">1000</span>
<span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">plot_isotropic_estimator</span><span class="p">(</span>
    <span class="n">k_norm</span><span class="p">,</span>
    <span class="n">sf_estimated</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
    <span class="n">error_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\widehat</span><span class="si">{S}</span><span class="s2">_{\mathrm</span><span class="si">{BC}</span><span class="s2">}(k)$&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./code/structure_factor/hankel_quadrature.py">Source code</a>, <a class="reference external" href="./code/structure_factor/hankel_quadrature.png">png</a>, <a class="reference external" href="./code/structure_factor/hankel_quadrature.hires.png">hires.png</a>, <a class="reference external" href="./code/structure_factor/hankel_quadrature.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="_images/hankel_quadrature.png" class="plot-directive" src="_images/hankel_quadrature.png" />
</figure>
<div class="proof proof-type-definition" id="id18">

    <div class="proof-title">
        <span class="proof-type">Definition </span>
        
    </div><div class="proof-content">
<p>The structure factor <span class="math notranslate nohighlight">\(S\)</span> of a <strong>stationary isotropic</strong> point process <span class="math notranslate nohighlight">\(\mathcal{X} \subset \mathbb{R}^d\)</span> with intensity <span class="math notranslate nohighlight">\(\rho\)</span>, can be defined via the Hankel transform <span class="math notranslate nohighlight">\(\mathcal{H}_{d/2 -1}\)</span> of order <span class="math notranslate nohighlight">\(d/2 -1\)</span> as follows,</p>
<div class="math notranslate nohighlight">
\[S(\|\mathbf{k}\|_2)
= 1 + \rho \frac{(2 \pi)^{d/2}}{\|\mathbf{k}\|_2^{d/2 -1}} \mathcal{H}_{d/2 -1}(\tilde g -1)(\|\mathbf{k}\|_2),
\quad \tilde g: x \mapsto g(x) x^{d/2 -1},\]</div>
<p>where, <span class="math notranslate nohighlight">\(g\)</span> is the pair correlation function of <span class="math notranslate nohighlight">\(\mathcal{X}\)</span>.</p>
<p>This is a result of the relation between the Symmetric Fourier transform and the Hankel Transform.
For more details, we refer to <span id="id11">[<a class="reference internal" href="bibliography/index.html#id4" title="Diala Hawat, Guillaume Gautier, Rémi Bardenet, and Raphaël Lachièze-Rey. On estimating the structure factor of a point process, with applications to hyperuniformity. arXiv preprint, 2022. arXiv: 2203.08749.">HGBLachiezeR22</a>]</span>, (Section 3.2).</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Typical usage</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Estimate the pair correlation function using <code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code>.</p></li>
<li><p>Clean and interpolate/extrapolate the resulting estimation using <code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code> to get a <strong>function</strong>.</p></li>
<li><p>Use the result as the input <code class="docutils literal notranslate"><span class="pre">pcf</span></code>.</p></li>
</ol>
</div></blockquote>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></p></li>
<li><p><a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.plot_isotropic_estimator" title="structure_factor.structure_factor.StructureFactor.plot_isotropic_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_isotropic_estimator()</span></code></a></p></li>
<li><p><a class="reference internal" href="spatial_windows.html#module-structure_factor.spatial_windows" title="structure_factor.spatial_windows"><code class="xref py py-class docutils literal notranslate"><span class="pre">spatial_windows</span></code></a></p></li>
<li><p><a class="reference internal" href="point_pattern.html#structure_factor.point_pattern.PointPattern" title="structure_factor.point_pattern.PointPattern"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PointPattern()</span></code></a></p></li>
<li><p><a class="reference internal" href="transforms.html#structure_factor.transforms.HankelTransformBaddourChouinard" title="structure_factor.transforms.HankelTransformBaddourChouinard"><code class="xref py py-class docutils literal notranslate"><span class="pre">HankelTransformBaddourChouinard</span></code></a></p></li>
<li><p><a class="reference internal" href="transforms.html#structure_factor.transforms.HankelTransformOgata" title="structure_factor.transforms.HankelTransformOgata"><code class="xref py py-class docutils literal notranslate"><span class="pre">HankelTransformOgata</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.plot_isotropic_estimator">
<span class="sig-name descname"><span class="pre">plot_isotropic_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_norm_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_sf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'grey'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'$\\widehat{S}$'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">binning_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.plot_isotropic_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.plot_isotropic_estimator" title="Permalink to this definition"></a></dt>
<dd><p>Display the outputs of the method <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic" title="structure_factor.structure_factor.StructureFactor.quadrature_estimator_isotropic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quadrature_estimator_isotropic()</span></code></a>, or <code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator_isotropic()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k_norm</strong> (<em>numpy.ndarray</em>) – Vector of wavenumbers (i.e., norms of wavevectors) on which the structure factor has been approximated.</p></li>
<li><p><strong>estimation</strong> (<em>numpy.ndarray</em>) – Approximation(s) of the structure factor corresponding to <code class="docutils literal notranslate"><span class="pre">k_norm</span></code>.</p></li>
<li><p><strong>axis</strong> (<em>plt.Axes</em><em>, </em><em>optional</em>) – Support axis of the plot. Defaults to None.</p></li>
<li><p><strong>scale</strong> (<em>str</em><em>, </em><em>optional</em>) – Trigger between plot scales of <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_xscale.html">see matplolib documentation</a>. Defaults to ‘log’.</p></li>
<li><p><strong>k_norm_min</strong> (<em>float</em><em>, </em><em>optional</em>) – Estimated lower bound of the wavenumbers. Defaults to None.</p></li>
<li><p><strong>exact_sf</strong> (<em>callable</em><em>, </em><em>optional</em>) – Theoretical structure factor of the point process. Defaults to None.</p></li>
<li><p><strong>error_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">k_norm</span></code> and correspondingly <code class="docutils literal notranslate"><span class="pre">estimation</span></code>, are divided into sub-intervals (bins). Over each bin, the mean and the standard deviation of <code class="docutils literal notranslate"><span class="pre">si</span></code> are derived and visualized on the plot.  Note that each error bar corresponds to the mean <span class="math notranslate nohighlight">\(\pm 3 \times\)</span> standard deviation. To specify the number of bins, add it as a keyword argument. For more details see <a class="reference internal" href="utils.html#structure_factor.utils._bin_statistics" title="structure_factor.utils._bin_statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_bin_statistics()</span></code></a>. Defaults to False.</p></li>
<li><p><strong>file_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name used to save the figure. The available output formats depend on the backend being used. Defaults to “”.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>binning_params</strong> – (dict): Used when <code class="docutils literal notranslate"><span class="pre">error_bar=True</span></code>, by the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils_bin_statistics()</span></code> as keyword arguments (except <code class="docutils literal notranslate"><span class="pre">&quot;statistic&quot;</span></code>) of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binned_statistic.html">scipy.stats.binned_statistic</a>.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Plot of the approximated structure factor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>plt.Axes</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator">
<span class="sig-name descname"><span class="pre">plot_non_isotropic_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'radial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_sf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'$\\widehat{S}$'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rasterized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">binning_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure_factor/structure_factor.html#StructureFactor.plot_non_isotropic_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#structure_factor.structure_factor.StructureFactor.plot_non_isotropic_estimator" title="Permalink to this definition"></a></dt>
<dd><p>Display the outputs of the method <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.scattering_intensity" title="structure_factor.structure_factor.StructureFactor.scattering_intensity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scattering_intensity()</span></code></a>, <a class="reference internal" href="#structure_factor.structure_factor.StructureFactor.tapered_estimator" title="structure_factor.structure_factor.StructureFactor.tapered_estimator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tapered_estimator()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>numpy.ndarray</em>) – Wavevector(s) on which the scattering intensity has been approximated. Array of size <span class="math notranslate nohighlight">\(n \times d\)</span>  where <span class="math notranslate nohighlight">\(d\)</span> is the dimension of the space, and <span class="math notranslate nohighlight">\(n\)</span> is the number of wavevectors.</p></li>
<li><p><strong>estimation</strong> (<em>numpy.ndarray</em>) – Approximated structure factor associated to <cite>k</cite>.</p></li>
<li><p><strong>axes</strong> (<em>plt.Axes</em><em>, </em><em>optional</em>) – Support axes of the plots. Defaults to None.</p></li>
<li><p><strong>scale</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Trigger between plot scales of <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_xscale.html">see matplolib documentation</a>. Defaults to “log”.</p>
</p></li>
<li><p><strong>plot_type</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Type of the plot to visualize, “radial”, “imshow”, or “all”. Defaults to “radial”.</p>
<ul>
<li><p>If “radial”, the output is a 1D plot of <cite>estimation</cite> w.r.t. the norm(s) of <cite>k</cite>.</p></li>
<li><p>If “imshow” (option available only for a 2D point process), the output is a 2D color level plot.</p></li>
<li><p>If “all” (option available only for a 2D point process), the result contains 3 subplots: the point pattern (or a restriction to a specific window if <code class="docutils literal notranslate"><span class="pre">window_res</span></code> is set), the radial plot, and the color level plot. Note that the options “imshow” and “all” couldn’t be used, if <code class="docutils literal notranslate"><span class="pre">k</span></code> couldn’t be reshaped as a meshgrid.</p></li>
</ul>
</p></li>
<li><p><strong>positive</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, consider only the positive values of <cite>estimation</cite>. Defaults to False.</p></li>
<li><p><strong>exact_sf</strong> (<em>callable</em><em>, </em><em>optional</em>) – Theoretical structure factor of the point process. Defaults to None.</p></li>
<li><p><strong>error_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">k_norm</span></code> and correspondingly <code class="docutils literal notranslate"><span class="pre">estimation</span></code>, are divided into sub-intervals (bins). Over each bin, the mean and the standard deviation of <code class="docutils literal notranslate"><span class="pre">estimation</span></code> are derived and visualized on the plot. Note that each error bar corresponds to the mean <span class="math notranslate nohighlight">\(\pm 3 \times\)</span> standard deviation. To specify the number of bins, add it as a keyword argument. For more details see <a class="reference internal" href="utils.html#structure_factor.utils._bin_statistics" title="structure_factor.utils._bin_statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_bin_statistics()</span></code></a>. Defaults to False.</p></li>
<li><p><strong>rasterized</strong> (<em>bool</em><em>, </em><em>optional</em>) – Rasterized option of <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#:~:text=float-,rasterized,-bool">matlplotlib.plot</a>. Defaults to True.</p></li>
<li><p><strong>file_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name used to save the figure. The available output formats depend on the backend being used. Defaults to “”.</p></li>
<li><p><strong>window_res</strong> (<a class="reference internal" href="spatial_windows.html#structure_factor.spatial_windows.AbstractSpatialWindow" title="structure_factor.spatial_windows.AbstractSpatialWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSpatialWindow</span></code></a>, optional) – New restriction window. Useful when the sample of points is large and “plt_type=’all’”, so for time and visualization purposes, it is better to restrict the plot of the point process to a smaller window. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>binning_params</strong> (<em>dict</em>) – <p>Used when <code class="docutils literal notranslate"><span class="pre">error_bar=True</span></code>, by the method <a class="reference internal" href="utils.html#structure_factor.utils._bin_statistics" title="structure_factor.utils._bin_statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_bin_statistics()</span></code></a> as keyword arguments (except <code class="docutils literal notranslate"><span class="pre">&quot;statistic&quot;</span></code>) of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binned_statistic.html">scipy.stats.binned_statistic</a>.</p>
</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Plot of the approximated structure factor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>plt.Axes</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="spatial_windows.html" class="btn btn-neutral float-left" title="Spatial windows" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tapers.html" class="btn btn-neutral float-right" title="Tapers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Diala Hawat.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>