
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>structure_factor.structure_factor &#8212; structure-factor  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/proof.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">structure-factor  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">structure_factor.structure_factor</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for structure_factor.structure_factor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">rpy2.robjects</span> <span class="k">as</span> <span class="nn">robjects</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interpolate</span>
<span class="kn">from</span> <span class="nn">spatstat_interface.interface</span> <span class="kn">import</span> <span class="n">SpatstatInterface</span>

<span class="kn">import</span> <span class="nn">structure_factor.utils</span> <span class="k">as</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">structure_factor.point_pattern</span> <span class="kn">import</span> <span class="n">PointPattern</span>
<span class="kn">from</span> <span class="nn">structure_factor.spatial_windows</span> <span class="kn">import</span> <span class="n">BoxWindow</span><span class="p">,</span> <span class="n">check_cubic_window</span>
<span class="kn">from</span> <span class="nn">structure_factor.transforms</span> <span class="kn">import</span> <span class="n">RadiallySymmetricFourierTransform</span>


<div class="viewcode-block" id="StructureFactor"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor">[docs]</a><span class="k">class</span> <span class="nc">StructureFactor</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Implementation of various estimators of the structure factor of a point process.</span>

<span class="sd">    Args:</span>
<span class="sd">        point_pattern (:py:class:`~structure_factor.point_pattern.PointPattern`): Object of type PointPattern containing a realization ``point_pattern.points`` of a point process, the window where the points were simulated ``point_pattern.window`` and (optionally) the intensity of the point process ``point_pattern.intensity``.</span>

<span class="sd">    .. proof:definition::</span>

<span class="sd">        The structure factor :math:`S` of a d dimensional stationary point process :math:`\mathcal{X}` with intensity :math:`\rho`, is defined by,</span>

<span class="sd">        .. math::</span>

<span class="sd">            S(\mathbf{k}) = 1 + \rho \mathcal{F}(g-1)(\mathbf{k}),</span>

<span class="sd">        where :math:`\mathcal{F}` denotes the Fourier transform, :math:`g` the pair correlation function of :math:`\mathcal{X}`, :math:`\mathbf{k}` a wave vector of :math:`\mathbb{R}^d` (we denote the associated wavenumber :math:`\|\mathbf{k}\|_2` by :math:`k`, :cite:`Tor18`, (Section 2.1, equation (13)).</span>

<span class="sd">    .. note::</span>

<span class="sd">        **This class contains:**</span>
<span class="sd">            - Three estimators of the structure factor:</span>
<span class="sd">                - :meth:`scattering_intensity`: The scattering intensity estimator.</span>
<span class="sd">                - :meth:`hankel_quadrature` with ``method=&quot;Ogata&quot;``: Based on Ogata quadrature for approximating the Hankel transform :cite:`Oga05`.</span>
<span class="sd">                - :meth:`hankel_quadrature` with ``method=&quot;BaddourChouinard&quot;``: Based on Baddour and Chouinard Discrete Hankel transform :cite:`BaCh15`.</span>
<span class="sd">            - Two estimators of the pair correlation function :</span>
<span class="sd">                - :meth:`compute_pcf` with ``method=&quot;ppp&quot;``: Uses Epanechnikov kernel and a bandwidth selected by Stoyan&#39;s rule of thumb.</span>
<span class="sd">                - :meth:`compute_pcf` with ``method=&quot;fv&quot;``: Uses the derivative of Ripley&#39;s K function.</span>

<span class="sd">                This 2 estimators are obtained using `spatstat-interface &lt;https://github.com/For-a-few-DPPs-more/spatstat-interface&gt;`_ which builds a hidden interface with the package `spatstat &lt;https://github.com/spatstat/spatstat&gt;`_ of the programming language R.</span>
<span class="sd">            - :meth:`interpolate_pcf`: Interpolates the output results of :meth:`compute_pcf`.</span>
<span class="sd">            - :meth:`plot_scattering_intensity`,  :meth:`plot_pcf` and :meth:`plot_sf_hankel_quadrature`: Visualize the output result of the methods :meth:`scattering_intensity`, :meth:`compute_pcf` and :meth:`hankel_quadrature` respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_pattern</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize StructureFactor from ``point_pattern``.</span>

<span class="sd">        Args:</span>
<span class="sd">            point_pattern (:py:class:`~structure_factor.point_pattern.PointPattern`): Object of type point pattern which contains a realization ``point_pattern.points`` of a point process, the window where the points were simulated ``point_pattern.window`` and (optionally) the intensity of the point process ``point_pattern.intensity``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_pattern</span><span class="p">,</span> <span class="n">PointPattern</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span> <span class="o">=</span> <span class="n">point_pattern</span>  <span class="c1"># the point pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_norm_min</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># minimal bounds on the wavenumbers for Ogata method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># meshgrid of allowed values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ambient dimension of the underlying point process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span><span class="o">.</span><span class="n">dimension</span>

<div class="viewcode-block" id="StructureFactor.scattering_intensity"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.scattering_intensity">[docs]</a>    <span class="k">def</span> <span class="nf">scattering_intensity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">k_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">meshgrid_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the scattering intensity (an estimator of the structure factor) of the point process encapsulated in ``point_pattern``.</span>
<span class="sd">        It is evaluated by default, on a specific set of wavevectors called **allowed wavevectors** that minimizes the approximation errors.</span>

<span class="sd">        Args:</span>

<span class="sd">            k (np.ndarray, optional): n wavevectors of d columns (d is the dimension of the space) on which the scattering intensity to be evaluated. It is recommended to keep the default ``k`` and to specify ``k_max`` instead, to get the evaluations on a subset of the total set of allowed wavevectors. Defaults to None.</span>

<span class="sd">            k_max (float, specific option for allowed wavevectors): Supremum of the components of the allowed wavevectors on which the scattering intensity to be evaluated; i.e., for any allowed wavevector :math:`\mathbf{k}=(k_1,...,k_d)`, :math:`k_i \leq k\_max` for all i. This implies that the maximum of the output vector ``k_norm`` will be approximately equal to the norm of the vector :math:`(k\_max, ... k\_max)`. Defaults to 5.</span>

<span class="sd">            meshgrid_shape (tuple, specific option for allowed wavevectors): Tuple of length `d`, where each element specifies the number of components over an axis. These axes are crossed to form a subset of :math:`\mathbb{Z}^d` used to construct a set of allowed wavevectors. i.g., if d=2, setting meshgid_shape=(2,3) will construct a meshgrid of allowed wavevectors formed by a vector of 2 values over the x-axis and a vector of 3 values over the y-axis. Defaults to None, which will run the calculation over **all** the allowed wavevectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple(numpy.ndarray, numpy.ndarray):</span>
<span class="sd">                - k_norm: Wavenumber(s) (i.e., the vector of the norm(s) of the wavevector(s)) on which the scattering intensity has been evaluated.</span>
<span class="sd">                - si: Evaluation(s) of the scattering intensity corresponding to ``k_norm``.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/si_example.py</span>
<span class="sd">                :language: python</span>
<span class="sd">                :lines: 1-19</span>
<span class="sd">                :emphasize-lines: 17-19</span>

<span class="sd">        .. proof:definition::</span>

<span class="sd">            The scattering intensity :math:`\widehat{S}_{SI}` is an ensemble estimator of the structure factor :math:`S` of an ergodic stationary point process :math:`\mathcal{X} \subset \mathbb{R}^d`. It is accessible from a realization :math:`\mathcal{X}\cap W =\{\mathbf{x}_i\}_{i=1}^N` of :math:`\mathcal{X}` within a **cubic** window :math:`W=[-L/2, L/2]^d`.</span>

<span class="sd">            .. math::</span>

<span class="sd">                \widehat{S}_{SI}(\mathbf{k}) =</span>
<span class="sd">                \frac{1}{N}\left\lvert</span>
<span class="sd">                    \sum_{j=1}^N</span>
<span class="sd">                        \exp(- i \left\langle \mathbf{k}, \mathbf{x_j} \right\rangle)</span>
<span class="sd">                \right\rvert^2</span>

<span class="sd">            for a specific set of wavevectors</span>

<span class="sd">            .. math::</span>
<span class="sd">                \mathbf{k} \in \{</span>
<span class="sd">                \frac{2 \pi}{L} \mathbf{n},\,</span>
<span class="sd">                \text{for} \; \mathbf{n} \in (\mathbb{Z}^d)^\ast \}</span>

<span class="sd">            called in the physics jargon **allowed wavevectors** or dual lattice :cite:`KlaLasYog20`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            **Typical usage**:</span>
<span class="sd">                - If the realization of the point process :math:`\{\mathbf{x}_j\}_{j=1}^N` is not supported on a cubic window, use the method :py:class:`~structure_factor.point_pattern.PointPattern.restrict_to_window` to extract a sub-sample within a cubic window.</span>
<span class="sd">                - Do not specify the input argument ``k``. It is rather recommended to specify ``k_max`` and/or ``meshgrid_shape`` if needed. This allows :meth:`scattering_intensity` to operate automatically on a set of allowed wavevectors (see :py:meth:`~structure_factor.utils.allowed_wave_vectors`).</span>

<span class="sd">            .. important::</span>

<span class="sd">                Specifying the meshgrid argument ``meshgrid_shape`` is useful if the number of points of the realization is big. In this case, the evaluation of :math:`\widehat{S}_{SI}` on the total set of allowed wavevectors may be time-consuming.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point_pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">point_pattern</span><span class="o">.</span><span class="n">window</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">point_pattern</span><span class="o">.</span><span class="n">dimension</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_max</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_max</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">BoxWindow</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;The window should be a &#39;cubic&#39; BoxWindow to minimize the error of approximating the structure factor by the scattering intensity. Hint: use PointPattern.restrict_to_window.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">meshgrid_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">meshgrid_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Each wavevector should belong to the same dimension (d) of the point process, i.e., len(meshgrid_shape) = d.&quot;</span>
                <span class="p">)</span>

            <span class="n">check_cubic_window</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">k</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">allowed_wave_vectors</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">k_max</span><span class="o">=</span><span class="n">k_max</span><span class="p">,</span> <span class="n">meshgrid_shape</span><span class="o">=</span><span class="n">meshgrid_shape</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;the vector of wave(s) should belong to the same dimension of the point process, i.e., `k` should have d columns.&quot;</span>
                <span class="p">)</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compute_scattering_intensity</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">point_pattern</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">k_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">k_norm</span><span class="p">,</span> <span class="n">si</span></div>

<div class="viewcode-block" id="StructureFactor.plot_scattering_intensity"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.plot_scattering_intensity">[docs]</a>    <span class="k">def</span> <span class="nf">plot_scattering_intensity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_norm</span><span class="p">,</span>
        <span class="n">si</span><span class="p">,</span>
        <span class="n">plot_type</span><span class="o">=</span><span class="s2">&quot;radial&quot;</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exact_sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">error_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">window_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">binning_params</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Visualize the results of the method :py:meth:`~structure_factor.structure_factor.StructureFactor.scattering_intensity`.</span>


<span class="sd">        Args:</span>
<span class="sd">            k_norm (numpy.array): Norm(s) of the wavevector(s) on which the scattering intensity has been approximated.</span>

<span class="sd">            si (numpy.array): Approximated scattering intensity associated to `k_norm`.</span>

<span class="sd">            plot_type (str, optional): (&quot;radial&quot;, &quot;imshow&quot;, &quot;all&quot;). Type of the plot to visualize. Defaults to &quot;radial&quot;.</span>

<span class="sd">                    - If &quot;radial&quot;, the output is a loglog plot.</span>
<span class="sd">                    - If &quot;imshow&quot; (option available only for a 2D point process), the output is a (2D) color level plot.</span>
<span class="sd">                    - If &quot;all&quot; (option available only for a 2D point process), the result contains 3 subplots: the point pattern (or a restriction to a specific window if ``window_res`` is set), the loglog radial plot, and the color level plot. Note that the options &quot;imshow&quot; and &quot;all&quot; couldn&#39;t be used, if ``k_norm`` is not a meshgrid.</span>

<span class="sd">            axes (matplotlib.axis, optional): Support axes of the plots. Defaults to None.</span>

<span class="sd">            exact_sf (callable, optional): Theoretical structure factor of the point process. Defaults to None.</span>

<span class="sd">            error_bar (bool, optional): If ``True``, ``k_norm`` and correspondingly ``si`` are divided into sub-intervals (bins). Over each bin, the mean and the standard deviation of ``si`` are derived and visualized on the plot. Note that each error bar corresponds to the mean +/- 3 standard deviation. To specify the number of bins, add it to the kwargs argument ``binning_params``. For more details see :py:meth:`~structure_factor.utils._bin_statistics`. Defaults to False.</span>

<span class="sd">            file_name (str, optional): Name used to save the figure. The available output formats depend on the backend being used. Defaults to &quot;&quot;.</span>

<span class="sd">            window_res (:py:class:`~structure_factor.spatial_windows.AbstractSpatialWindow`, optional): New restriction window. It is useful when the sample of points is large, so for time and visualization purposes, it is better to restrict the plot of the point process to a smaller window. Defaults to None.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            binning_params: (dict): Used when ``error_bar=True``, by the method :py:meth:`~structure_factor.utils_bin_statistics` as keyword arguments (except ``&quot;statistic&quot;``) of ``scipy.stats.binned_statistic``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.plot: Plot of the approximated structure factor.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/si_example.py</span>
<span class="sd">                :language: python</span>
<span class="sd">                :lines: 22-29</span>

<span class="sd">            .. plot:: code/si_example.py</span>
<span class="sd">                :include-source: False</span>
<span class="sd">                :alt: alternate text</span>
<span class="sd">                :align: center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;radial&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">plot_si_showcase</span><span class="p">(</span>
                <span class="n">k_norm</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">exact_sf</span><span class="p">,</span> <span class="n">error_bar</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">**</span><span class="n">binning_params</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;imshow&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;This plot option is adapted only for a 2D point process. Please use plot_type =&#39;radial&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The option &#39;imshow&#39; is available for 2D evaluations. Choose plot_type= &#39;radial&#39; or re-evaluate the scattering intensity on the meshgrid of allowed wave vectors.&quot;</span>
                <span class="p">)</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span><span class="p">)</span>
            <span class="n">k_norm</span> <span class="o">=</span> <span class="n">k_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">plot_si_imshow</span><span class="p">(</span><span class="n">k_norm</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The option &#39;all&#39; is available for 2D point processes.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The option &#39;imshow&#39; is available for 2D evaluations. Choose plot_type= &#39;radial&#39; or re-evaluate the scattering intensity on the meshgrid of allowed wave vectors.&quot;</span>
                <span class="p">)</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span><span class="p">)</span>
            <span class="n">k_norm</span> <span class="o">=</span> <span class="n">k_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K_shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">plot_si_all</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span><span class="p">,</span>
                <span class="n">k_norm</span><span class="p">,</span>
                <span class="n">si</span><span class="p">,</span>
                <span class="n">exact_sf</span><span class="p">,</span>
                <span class="n">error_bar</span><span class="p">,</span>
                <span class="n">file_name</span><span class="p">,</span>
                <span class="n">window_res</span><span class="p">,</span>
                <span class="o">**</span><span class="n">binning_params</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;plot_type must be chosen among (&#39;all&#39;, &#39;radial&#39;, &#39;imshow&#39;).&quot;</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="StructureFactor.compute_pcf"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.compute_pcf">[docs]</a>    <span class="k">def</span> <span class="nf">compute_pcf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fv&quot;</span><span class="p">,</span> <span class="n">install_spatstat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the pair correlation function (pcf) of the point process encapsulated in ``point_pattern`` (only for stationary isotropic point processes of :math:`\mathbb{R}^2`). The available methods are the methods ``spastat.core.pcf_ppp`` and ``spastat.core.pcf_fv`` of the `R` package `spatstat &lt;https://github.com/spatstat/spatstat&gt;`_.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This function requires the `R programming language &lt;https://cran.r-project.org/&gt;`_ to be installed on your local machine since it relies on the Python package `spatstat-interface &lt;https://github.com/For-a-few-DPPs-more/spatstat-interface&gt;`_. This doesn&#39;t require any knowledge of the programming language R.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (str, optional): Choose between ``&quot;ppp&quot;`` or ``&quot;fv&quot;`` referring respectively to `spatstat.core.pcf.ppp &lt;https://www.rdocumentation.org/packages/spatstat.core/versions/2.1-2/topics/pcf.ppp&gt;`_ and `spatsta.core.pcf.fv &lt;https://www.rdocumentation.org/packages/spatstat.core/versions/2.1-2/topics/pcf.fv&gt;`_. These 2 methods approximate the pair correlation function of a point process from a realization of the underlying point process using some edge corrections and some basic approximations. For more details see :cite:`Rbook15`. Defaults to ``&quot;fv&quot;``.</span>

<span class="sd">            install_spatstat (bool, optional): If ``True``, the `R` package `spatstat &lt;https://github.com/spatstat/spatstat&gt;`_  will be automatically updated or installed (if not present) on your local machine, see also `spatstat-interface &lt;https://github.com/For-a-few-DPPs-more/spatstat-interface&gt;`_. Note that this requires the installation of the `R programming language &lt;https://cran.r-project.org/&gt;`_ on your local machine.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            params (dict):</span>
<span class="sd">                - if ``method = &quot;ppp&quot;``</span>
<span class="sd">                    - keyword arguments of `spastat.core.pcf.ppp &lt;https://rdrr.io/cran/spatstat.core/man/pcf.ppp.html&gt;`_,</span>
<span class="sd">                - if ``method = &quot;fv&quot;``</span>
<span class="sd">                    - Kest = dict(keyword arguments of `spastat.core.Kest &lt;https://rdrr.io/github/spatstat/spatstat.core/man/Kest.html&gt;`_),</span>
<span class="sd">                    - fv = dict( keyword arguments of `spastat.core.pcf.fv &lt;https://rdrr.io/cran/spatstat.core/man/pcf.fv.html&gt;`_).</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: Version of the output of `spatstat.core.pcf.ppp &lt;https://www.rdocumentation.org/packages/spatstat.core/versions/2.1-2/topics/pcf.ppp&gt;`_ or `spatsta.core.pcf.fv &lt;https://www.rdocumentation.org/packages/spatstat.core/versions/2.1-2/topics/pcf.fv&gt;`_. The first column of the DataFrame is the set of radius on which the pair correlation function was approximated. The others correspond to the approximated pair correlation function with different edge corrections.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/pcf_example.py</span>
<span class="sd">                :language: python</span>
<span class="sd">                :lines: 1-14</span>
<span class="sd">                :emphasize-lines: 12-14</span>

<span class="sd">        .. proof:definition::</span>

<span class="sd">            The pair correlation function of a stationary point process :math:`\mathcal{X}` of intensity :math:`\rho` is the function :math:`g` satisfying (when it exists),</span>

<span class="sd">            .. math::</span>

<span class="sd">                \mathbb{E} \bigg[ \sum_{\mathbf{x}, \mathbf{y} \in \mathcal{X}}^{\neq}</span>
<span class="sd">                f(\mathbf{x}, \mathbf{y}) \bigg] = \int_{\mathbb{R}^d \times \mathbb{R}^d} f(\mathbf{x}+\mathbf{y}, \mathbf{y})\rho^{2} g(\mathbf{x}) \mathrm{d} \mathbf{x} \mathrm{d}\mathbf{y},</span>

<span class="sd">            for any non-negative smooth function :math:`f`  with compact support.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ppp&quot;</span><span class="p">,</span> <span class="s2">&quot;fv&quot;</span><span class="p">)</span>

        <span class="c1"># core, geom and other subpackages are updated if install_spatstat</span>
        <span class="n">spatstat</span> <span class="o">=</span> <span class="n">SpatstatInterface</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="n">install_spatstat</span><span class="p">)</span>
        <span class="n">spatstat</span><span class="o">.</span><span class="n">import_package</span><span class="p">(</span><span class="s2">&quot;core&quot;</span><span class="p">,</span> <span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span><span class="o">.</span><span class="n">convert_to_spatstat_ppp</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ppp&quot;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">pcf</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">pcf_ppp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;fv&quot;</span><span class="p">:</span>
            <span class="n">params_Kest</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Kest&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
            <span class="n">Kest_r</span> <span class="o">=</span> <span class="n">params_Kest</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Kest_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Kest_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">params_Kest</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">Kest_r</span><span class="p">)</span>
            <span class="n">k_ripley</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Kest</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">params_Kest</span><span class="p">)</span>
            <span class="n">params_fv</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fv&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
            <span class="n">pcf</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">pcf_fv</span><span class="p">(</span><span class="n">k_ripley</span><span class="p">,</span> <span class="o">**</span><span class="n">params_fv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pcf</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">pcf</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;theo&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureFactor.plot_pcf"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.plot_pcf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pcf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcf_dataframe</span><span class="p">,</span> <span class="n">exact_pcf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the data frame output of the method :py:meth:`~structure_factor.structure_factor.StructureFactor.compute_pcf`.</span>

<span class="sd">        Args:</span>
<span class="sd">            pcf_dataframe (pandas.DataFrame): Output DataFrame of the method :py:meth:`~structure_factor.structure_factor.StructureFactor.compute_pcf`.</span>

<span class="sd">            exact_pcf (callable, optional): Function representing the theoretical pair correlation function of the point process. Defaults to None.</span>

<span class="sd">            file_name (str, optional): Name used to save the figure. The available output formats depend on the backend being used. Defaults to &quot;&quot;.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            kwargs (dict): Keyword arguments of the function `pandas.DataFrame.plot.line &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.line.html&gt;`_.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.plot: Plot of the output of :py:meth:`~structure_factor.structure_factor.StructureFactor.compute_pcf`.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/pcf_example.py</span>
<span class="sd">                :language: python</span>
<span class="sd">                :lines: 16-</span>

<span class="sd">            .. plot:: code/pcf_example.py</span>
<span class="sd">                :include-source: False</span>
<span class="sd">                :alt: alternate text</span>
<span class="sd">                :align: center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">plot_pcf</span><span class="p">(</span><span class="n">pcf_dataframe</span><span class="p">,</span> <span class="n">exact_pcf</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureFactor.interpolate_pcf"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.interpolate_pcf">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_pcf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pcf_r</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean (i.e., replace the possible nan, posinf and neginf by zero) and interpolate the vector ``pcf_r`` evaluated at ``r``.</span>

<span class="sd">        Args:</span>
<span class="sd">            r (numpy.ndarray): Vector of radius. Typically, the first colomun of the output of the method :py:meth:`~structure_factor.structure_factor.StructureFactor.compute_pcf`.</span>

<span class="sd">            pcf_r (numpy.ndarray): Vector of approximations of the pair correlation function. Typically, a column from the output of the method :py:meth:`~structure_factor.structure_factor.StructureFactor.compute_pcf`.</span>

<span class="sd">            clean (bool, optional): Replace nan, posinf and neginf values of ``pcf_r`` by zero before interpolating. Defaults to True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            params (dict): Keyword arguments of the function `scipy.interpolate.interp1d &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html&gt;`_.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple (dict, callable): Dictionary containing the bounds of the support of ``r`` and the resulting output function of the interpolation of ``pcf_r``.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/sf_baddour_example.py</span>
<span class="sd">                :language: python</span>
<span class="sd">                :lines: 18-21</span>

<span class="sd">        .. note::</span>
<span class="sd">            Typically ``pcf_r`` is an approximation of the pair correlation function using the method :py:meth:`~structure_factor.structure_factor.StructureFactor.compute_pcf`. The failure of the approximation method on some specific radius may lead to some bad data like nan, posinf and neginf. This may happen for small radiuses, the reason for replacing them with zero. see :cite:`Rbook15`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;kind&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
        <span class="n">rmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">r_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span>
            <span class="n">pcf_r</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">set_nan_inf_to_zero</span><span class="p">(</span><span class="n">pcf_r</span><span class="p">)</span>

        <span class="n">dict_rmin_r_max</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rmin</span><span class="o">=</span><span class="n">rmin</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">r_max</span><span class="p">)</span>
        <span class="n">pcf</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">pcf_r</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_rmin_r_max</span><span class="p">,</span> <span class="n">pcf</span></div>

<div class="viewcode-block" id="StructureFactor.hankel_quadrature"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.hankel_quadrature">[docs]</a>    <span class="k">def</span> <span class="nf">hankel_quadrature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcf</span><span class="p">,</span> <span class="n">k_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;BaddourChouinard&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Approximate the structure factor of the point process encapsulated in ``point_pattern`` (only for stationary isotropic point processes), using specific approximations of the Hankel transform.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method is actually applicable for 2-dimensional point processes.</span>

<span class="sd">        Args:</span>
<span class="sd">            pcf (callable): Radially symmetric pair correlation function.</span>

<span class="sd">            k_norm (numpy.ndarray, optional): Vector of wavenumbers (i.e., norms of wave vectors) where the structure factor is to be evaluated. Optional if ``method=&quot;BaddourChouinard&quot;`` (since this method evaluates the Hankel transform on a specific vector, see :cite:`BaCh15`), but it is **non optional** if ``method=&quot;Ogata&quot;``. Defaults to None.</span>

<span class="sd">            method (str, optional): Choose between ``&quot;BaddourChouinard&quot;`` or ``&quot;Ogata&quot;``. Defaults to ``&quot;BaddourChouinard&quot;``. Selects the method to be used to compute the Hankel transform corresponding to the symmetric Fourier transform of ``pcf -1``,</span>

<span class="sd">                - if ``&quot;BaddourChouinard&quot;``: The Hankel transform is approximated using the Discrete Hankel transform :cite:`BaCh15`. See :py:class:`~structure_factor.transforms.HankelTransformBaddourChouinard`,</span>
<span class="sd">                - if ``&quot;Ogata&quot;``: The Hankel transform is approximated using Ogata quadrature :cite:`Oga05`. See :py:class:`~structure_factor.transforms.HankelTransformOgata`.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            params (dict): Keyword arguments passed to the corresponding Hankel transformer selected according to the ``method`` argument.</span>

<span class="sd">                - ``method == &quot;Ogata&quot;``, see :py:meth:`~structure_factor.transforms.HankelTransformOgata.compute_transformation_parameters`</span>
<span class="sd">                    - ``step_size``</span>
<span class="sd">                    - ``nb_points``</span>

<span class="sd">                - ``method == &quot;BaddourChouinard&quot;``, see :py:meth:`~structure_factor.transforms.HankelTransformBaddourChouinard.compute_transformation_parameters`</span>
<span class="sd">                    - ``r_max``</span>
<span class="sd">                    - ``nb_points``</span>
<span class="sd">                    - ``interpolotation`` dictionnary containing the keyword arguments of `scipy.integrate.interp1d &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html&gt;`_ parameters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple (np.ndarray, np.ndarray):</span>
<span class="sd">                - k_norm: Vector of wavenumbers.</span>
<span class="sd">                - sf: Evaluations of the structure factor on ``k_norm``.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/sf_baddour_example.py</span>
<span class="sd">                :lines: 1-28</span>
<span class="sd">                :emphasize-lines: 23-28</span>

<span class="sd">        .. proof:definition::</span>

<span class="sd">            The structure factor :math:`S` of a **stationary isotropic** point process :math:`\mathcal{X} \subset \mathbb{R}^d` of intensity :math:`\rho`, can be defined via the Hankel transform :math:`\mathcal{H}_{d/2 -1}` of order :math:`d/2 -1` as follows,</span>

<span class="sd">            .. math::</span>

<span class="sd">                S(\|\mathbf{k}\|)</span>
<span class="sd">                = 1 + \rho \frac{(2 \pi)^{d/2}}{\|\mathbf{k}\|^{d/2 -1}} \mathcal{H}_{d/2 -1}(\tilde g -1)(\|\mathbf{k}\|),</span>
<span class="sd">                \quad \tilde g: x \mapsto g(x) x^{d/2 -1},</span>

<span class="sd">            where, :math:`g` is the pair correlation function of :math:`\mathcal{X}`.</span>
<span class="sd">            This is a result of the relation between the Symmetric Fourier transform and the Hankel Transform.</span>

<span class="sd">        .. note::</span>

<span class="sd">            **Typical usage**:</span>
<span class="sd">                1. Estimate the pair correlation function using :py:meth:`compute_pcf`.</span>

<span class="sd">                2. Clean and interpolate the resulting estimation using :py:meth:`interpolate_pcf` to get a **function**.</span>

<span class="sd">                3. Pass the resulting interpolated function to :py:meth:`hankel_quadrature` to get an approximation of the structure factor of the point process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;This method is actually applicable for 2-dimensional point processes&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">pcf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Ogata&quot;</span> <span class="ow">and</span> <span class="n">k_norm</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;k_norm is not optional while using method=&#39;Ogata&#39;. Please provide a vector k_norm in the input. &quot;</span>
            <span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;r_max&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;BaddourChouinard&quot;</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;r_max&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;r_max is not optional while using method=&#39;BaddourChouinard&#39;. Please specify r_max in the input. &quot;</span>
            <span class="p">)</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">RadiallySymmetricFourierTransform</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">total_pcf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">pcf</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
        <span class="n">k_norm</span><span class="p">,</span> <span class="n">ft_k</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">total_pcf</span><span class="p">,</span> <span class="n">k_norm</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Ogata&quot;</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;r_max&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;step_size&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
            <span class="n">step_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;step_size&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_norm_min</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_compute_k_min</span><span class="p">(</span>
                <span class="n">r_max</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;r_max&quot;</span><span class="p">],</span> <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span>
            <span class="p">)</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_pattern</span><span class="o">.</span><span class="n">intensity</span> <span class="o">*</span> <span class="n">ft_k</span>
        <span class="k">return</span> <span class="n">k_norm</span><span class="p">,</span> <span class="n">sf</span></div>

<div class="viewcode-block" id="StructureFactor.plot_sf_hankel_quadrature"><a class="viewcode-back" href="../../structure_factor.html#structure_factor.structure_factor.StructureFactor.plot_sf_hankel_quadrature">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sf_hankel_quadrature</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_norm</span><span class="p">,</span>
        <span class="n">sf</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">k_norm_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exact_sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">error_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">binning_params</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Display the output of :py:meth:`hankel_quadrature`.</span>

<span class="sd">        Args:</span>
<span class="sd">            k_norm (np.array): Vector of wavenumbers (i.e., norms of waves) on which the structure factor has been approximated.</span>

<span class="sd">            sf (np.array): Approximation of the structure factor corresponding to ``k_norm``.</span>

<span class="sd">            axis (matplotlib.axis, optional): Support axis of the plots. Defaults to None.</span>

<span class="sd">            k_norm_min (float, optional): Estimated lower bound of the wavenumbers (only when ``sf`` was approximated using **Ogata quadrature**). Defaults to None.</span>

<span class="sd">            exact_sf (callable, optional): Theoretical structure factor of the point process. Defaults to None.</span>

<span class="sd">            error_bar (bool, optional): If ``True``, ``k_norm`` and correspondingly ``si`` are divided into sub-intervals (bins). Over each bin, the mean and the standard deviation of ``si`` are derived and visualized on the plot. Note that each error bar corresponds to the mean +/- 3 standard deviation. To specify the number of bins, add it to the kwargs argument ``binning_params``. For more details see :py:meth:`~structure_factor.utils._bin_statistics`. Defaults to False.</span>

<span class="sd">            file_name (str, optional): Name used to save the figure. The available output formats depend on the backend being used. Defaults to &quot;&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.plot: Plot the output of :py:meth:`~structure_factor.structure_factor.StructureFactor.hankel_quadrature`.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. literalinclude:: code/sf_baddour_example.py</span>
<span class="sd">                :lines: 31-</span>

<span class="sd">            .. plot:: code/sf_baddour_example.py</span>
<span class="sd">                :include-source: False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">plot_sf_hankel_quadrature</span><span class="p">(</span>
            <span class="n">k_norm</span><span class="p">,</span>
            <span class="n">sf</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">k_norm_min</span><span class="p">,</span>
            <span class="n">exact_sf</span><span class="p">,</span>
            <span class="n">error_bar</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="o">**</span><span class="n">binning_params</span>
        <span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">structure-factor  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">structure_factor.structure_factor</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Diala Hawat.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.0.
    </div>
  </body>
</html>